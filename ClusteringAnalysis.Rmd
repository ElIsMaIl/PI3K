---
title: "Clustering analysis"
description: |
  Overview of data analysis.
author:
  - name: Manuela Benary / Mohammad El-Ismail
    affiliation: CUBI / CCCC
    affiliation_url: 
date: "`r Sys.Date()`"
bibliography: literature.bib
output: 
  distill::distill_article:
    toc: true
    toc_depth: 2
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r load-libraries}
library(Matrix)
library(Matrix.utils)
library(tidyverse)
library(rtracklayer)
library(Seurat)
library(knitr)
library(janitor)
library(ggsci)
library(ggpubr)
library(cowplot)
library(dplyr)
library(DT)
library(biomaRt)
library(gplots)
library(clusterProfiler)
library(org.Hs.eg.db)
library(SingleCellExperiment)
library(scales)
library(RCurl)
source("helperFunctions.R")
```

```{r load-data}
integrated_seurat <- readRDS("data/integrated_seurat.rds")
```

## Clustering cells based on top PCs (metagenes)

```{r explore-heatmap-of-PCs}
print(x = integrated_seurat[["pca"]], 
      dims = 1:10, 
      nfeatures = 5)
```

```{r elbow plot}
ElbowPlot(object = integrated_seurat,
          ndims = 30)
```

```{r percent of variation associated with each PC}
pct <- integrated_seurat[["pca"]]@stdev / sum(integrated_seurat[["pca"]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)

#  Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]
co1

# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
co2

pcs <- min(co1, co2)

```

```{r}
# Create a dataframe with values
plot_df <- data.frame(pct = pct, 
           cumu = cumu, 
           rank = 1:length(pct))

# Elbow plot to visualize 
  ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > pcs)) + 
  geom_text() + 
  geom_vline(xintercept = 90, color = "grey") + 
  geom_hline(yintercept = min(pct[pct > 5]), color = "grey") +
  theme_bw()
```

```{r}
# Determine the K-nearest neighbor graph
integrated_seurat <- FindNeighbors(object = integrated_seurat, 
                                dims = 1:30)

# Explore resolutions
integrated_seurat@meta.data %>% 
        View()


# Determine the clusters for various resolutions                                
integrated_seurat <- FindClusters(object = integrated_seurat, resolution = 0.5)
```

```{r}
# Assign identity of clusters
Idents(object = integrated_seurat) <- "integrated_snn_res.0.5"
```

```{r}
DimPlot(integrated_seurat,
        reduction = "umap",
        label = TRUE,
        label.size = 6)
```

## Quality Control Cluster Analysis
# Segregation of clusters by sample

```{r}
# Extract identity and sample information from seurat object to determine the number of cells per cluster per sample
n_cells <- FetchData(integrated_seurat, 
                     vars = c("ident", "orig.ident")) %>%
        dplyr::count(ident, orig.ident) %>%
        tidyr::spread(ident, n)

# View table
View(n_cells)

datatable(n_cells,
          caption = "The table shows the number of cells per cluster per sample")

```

```{r}
# UMAP of cells in each cluster by sample
DimPlot(integrated_seurat, 
        label = TRUE, 
        group.by = "sample")  + NoLegend()
```

# Segregation of clusters by cell cycle phase

```{r}
# Explore whether clusters segregate by cell cycle phase
DimPlot(integrated_seurat,
        label = TRUE, 
        split.by = "Phase")  + NoLegend()
```

# Segregation of clusters by various sources of uninteresting variation

```{r}
# Determine metrics to plot present in seurat_integrated@meta.data
metrics <-  c("nUMI", "nGene", "S.Score", "G2M.Score", "percent.mt")

FeaturePlot(integrated_seurat, 
            reduction = "umap", 
            features = metrics,
            pt.size = 0.4, 
            order = TRUE,
            min.cutoff = 'q10',
            label = TRUE)
```

# Exploration of the PCs driving the different clusters

```{r}
# Defining the information in the seurat object of interest
columns <- c(paste0("PC_", 1:16),
            "ident",
            "UMAP_1", "UMAP_2")

# Extracting this data from the seurat object
pc_data <- FetchData(integrated_seurat, 
                     vars = columns)
```

```{r}
# Adding cluster label to center of cluster on UMAP
umap_label <- FetchData(integrated_seurat, 
                        vars = c("ident", "UMAP_1", "UMAP_2"))  %>%
  group_by(ident) %>%
  summarise(x=mean(UMAP_1), y=mean(UMAP_2))
  
# Plotting a UMAP plot for each of the PCs
map(paste0("PC_", 1:16), function(pc){
        ggplot(pc_data, 
               aes(UMAP_1, UMAP_2)) +
                geom_point(aes_string(color=pc), 
                           alpha = 0.7) +
                scale_color_gradient(guide = FALSE, 
                                     low = "grey90", 
                                     high = "blue")  +
                geom_text(data=umap_label, 
                          aes(label=ident, x, y)) +
                ggtitle(pc)
}) %>% 
        plot_grid(plotlist = .)
```

```{r}
# Examine PCA results 
print(integrated_seurat[["pca"]], dims = 1:5, nfeatures = 5)
```

# Exploring known cell type markers

```{r}
#DimPlot(object = integrated_seurat, 
#        reduction = "umap", 
#        label = TRUE) + NoLegend()
```

```{r}
# Select the RNA counts slot to be the default assay
DefaultAssay(integrated_seurat) <- "RNA"

# Normalize RNA data for visualization purposes
seurat_integrated <- NormalizeData(integrated_seurat, verbose = FALSE)
```

```{r}
saveRDS(integrated_seurat, "data/integrated_seurat_RNA.rds")
```


